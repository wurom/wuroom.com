/*! ieg-portal */
jQuery.easing.jswing = jQuery.easing.swing, jQuery.extend(jQuery.easing, {
        def: "easeOutQuad",
        swing: function (e, f, a, h, g) {
            return jQuery.easing[jQuery.easing.def](e, f, a, h, g)
        }, easeInQuad: function (e, f, a, h, g) {
            return h * (f /= g) * f + a
        }, easeOutQuad: function (e, f, a, h, g) {
            return -h * (f /= g) * (f - 2) + a
        }, easeInOutQuad: function (e, f, a, h, g) {
            return (f /= g / 2) < 1 ? h / 2 * f * f + a : -h / 2 * (--f * (f - 2) - 1) + a
        }, easeInCubic: function (e, f, a, h, g) {
            return h * (f /= g) * f * f + a
        }, easeOutCubic: function (e, f, a, h, g) {
            return h * ((f = f / g - 1) * f * f + 1) + a
        }, easeInOutCubic: function (e, f, a, h, g) {
            return (f /= g / 2) < 1 ? h / 2 * f * f * f + a : h / 2 * ((f -= 2) * f * f + 2) + a
        }, easeInQuart: function (e, f, a, h, g) {
            return h * (f /= g) * f * f * f + a
        }, easeOutQuart: function (e, f, a, h, g) {
            return -h * ((f = f / g - 1) * f * f * f - 1) + a
        }, easeInOutQuart: function (e, f, a, h, g) {
            return (f /= g / 2) < 1 ? h / 2 * f * f * f * f + a : -h / 2 * ((f -= 2) * f * f * f - 2) + a
        }, easeInQuint: function (e, f, a, h, g) {
            return h * (f /= g) * f * f * f * f + a
        }, easeOutQuint: function (e, f, a, h, g) {
            return h * ((f = f / g - 1) * f * f * f * f + 1) + a
        }, easeInOutQuint: function (e, f, a, h, g) {
            return (f /= g / 2) < 1 ? h / 2 * f * f * f * f * f + a : h / 2 * ((f -= 2) * f * f * f * f + 2) + a
        }, easeInSine: function (e, f, a, h, g) {
            return -h * Math.cos(f / g * (Math.PI / 2)) + h + a
        }, easeOutSine: function (e, f, a, h, g) {
            return h * Math.sin(f / g * (Math.PI / 2)) + a
        }, easeInOutSine: function (e, f, a, h, g) {
            return -h / 2 * (Math.cos(Math.PI * f / g) - 1) + a
        }, easeInExpo: function (e, f, a, h, g) {
            return 0 == f ? a : h * Math.pow(2, 10 * (f / g - 1)) + a
        }, easeOutExpo: function (e, f, a, h, g) {
            return f == g ? a + h : h * (-Math.pow(2, -10 * f / g) + 1) + a
        }, easeInOutExpo: function (e, f, a, h, g) {
            return 0 == f ? a : f == g ? a + h : (f /= g / 2) < 1 ? h / 2 * Math.pow(2, 10 * (f - 1)) + a : h / 2 * (-Math.pow(2, -10 * --f) + 2) + a
        }, easeInCirc: function (e, f, a, h, g) {
            return -h * (Math.sqrt(1 - (f /= g) * f) - 1) + a
        }, easeOutCirc: function (e, f, a, h, g) {
            return h * Math.sqrt(1 - (f = f / g - 1) * f) + a
        }, easeInOutCirc: function (e, f, a, h, g) {
            return (f /= g / 2) < 1 ? -h / 2 * (Math.sqrt(1 - f * f) - 1) + a : h / 2 * (Math.sqrt(1 - (f -= 2) * f) + 1) + a
        }, easeInElastic: function (f, h, e, l, k) {
            var i = 1.70158,
                j = 0,
                g = l;
            if (0 == h) return e;
            if (1 == (h /= k)) return e + l;
            if (j || (j = .3 * k), g < Math.abs(l)) {
                g = l;
                var i = j / 4
            } else var i = j / (2 * Math.PI) * Math.asin(l / g);
            return -(g * Math.pow(2, 10 * (h -= 1)) * Math.sin(2 * (h * k - i) * Math.PI / j)) + e
        }, easeOutElastic: function (f, h, e, l, k) {
            var i = 1.70158,
                j = 0,
                g = l;
            if (0 == h) return e;
            if (1 == (h /= k)) return e + l;
            if (j || (j = .3 * k), g < Math.abs(l)) {
                g = l;
                var i = j / 4
            } else var i = j / (2 * Math.PI) * Math.asin(l / g);
            return g * Math.pow(2, -10 * h) * Math.sin(2 * (h * k - i) * Math.PI / j) + l + e
        }, easeInOutElastic: function (f, h, e, l, k) {
            var i = 1.70158,
                j = 0,
                g = l;
            if (0 == h) return e;
            if (2 == (h /= k / 2)) return e + l;
            if (j || (j = .3 * k * 1.5), g < Math.abs(l)) {
                g = l;
                var i = j / 4
            } else var i = j / (2 * Math.PI) * Math.asin(l / g);
            return 1 > h ? -.5 * g * Math.pow(2, 10 * (h -= 1)) * Math.sin(2 * (h * k - i) * Math.PI / j) + e : g * Math.pow(2, -10 * (h -= 1)) * Math.sin(2 * (h * k - i) * Math.PI / j) * .5 + l + e
        }, easeInBack: function (e, f, a, i, h, g) {
            return void 0 == g && (g = 1.70158), i * (f /= h) * f * ((g + 1) * f - g) + a
        }, easeOutBack: function (e, f, a, i, h, g) {
            return void 0 == g && (g = 1.70158), i * ((f = f / h - 1) * f * ((g + 1) * f + g) + 1) + a
        }, easeInOutBack: function (e, f, a, i, h, g) {
            return void 0 == g && (g = 1.70158), (f /= h / 2) < 1 ? i / 2 * f * f * (((g *= 1.525) + 1) * f - g) + a : i / 2 * ((f -= 2) * f * (((g *= 1.525) + 1) * f + g) + 2) + a
        }, easeInBounce: function (e, f, a, h, g) {
            return h - jQuery.easing.easeOutBounce(e, g - f, 0, h, g) + a
        }, easeOutBounce: function (e, f, a, h, g) {
            return (f /= g) < 1 / 2.75 ? 7.5625 * h * f * f + a : 2 / 2.75 > f ? h * (7.5625 * (f -= 1.5 / 2.75) * f + .75) + a : 2.5 / 2.75 > f ? h * (7.5625 * (f -= 2.25 / 2.75) * f + .9375) + a : h * (7.5625 * (f -= 2.625 / 2.75) * f + .984375) + a
        }, easeInOutBounce: function (e, f, a, h, g) {
            return g / 2 > f ? .5 * jQuery.easing.easeInBounce(e, 2 * f, 0, h, g) + a : .5 * jQuery.easing.easeOutBounce(e, 2 * f - g, 0, h, g) + .5 * h + a
        }
    }),
    function (factory) {
        "function" == typeof define && define.amd ? define(["jquery"], factory) : "object" == typeof exports ? module.exports = factory : factory(jQuery)
    }(function ($) {
        function handler(event) {
            var orgEvent = event || window.event,
                args = slice.call(arguments, 1),
                delta = 0,
                deltaX = 0,
                deltaY = 0,
                absDelta = 0,
                offsetX = 0,
                offsetY = 0;
            if (event = $.event.fix(orgEvent), event.type = "mousewheel", "detail" in orgEvent && (deltaY = -1 * orgEvent.detail), "wheelDelta" in orgEvent && (deltaY = orgEvent.wheelDelta), "wheelDeltaY" in orgEvent && (deltaY = orgEvent.wheelDeltaY), "wheelDeltaX" in orgEvent && (deltaX = -1 * orgEvent.wheelDeltaX), "axis" in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS && (deltaX = -1 * deltaY, deltaY = 0), delta = 0 === deltaY ? deltaX : deltaY, "deltaY" in orgEvent && (deltaY = -1 * orgEvent.deltaY, delta = deltaY), "deltaX" in orgEvent && (deltaX = orgEvent.deltaX, 0 === deltaY && (delta = -1 * deltaX)), 0 !== deltaY || 0 !== deltaX) {
                if (1 === orgEvent.deltaMode) {
                    var lineHeight = $.data(this, "mousewheel-line-height");
                    delta *= lineHeight, deltaY *= lineHeight, deltaX *= lineHeight
                } else if (2 === orgEvent.deltaMode) {
                    var pageHeight = $.data(this, "mousewheel-page-height");
                    delta *= pageHeight, deltaY *= pageHeight, deltaX *= pageHeight
                }
                if (absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX)), (!lowestDelta || lowestDelta > absDelta) && (lowestDelta = absDelta, shouldAdjustOldDeltas(orgEvent, absDelta) && (lowestDelta /= 40)), shouldAdjustOldDeltas(orgEvent, absDelta) && (delta /= 40, deltaX /= 40, deltaY /= 40), delta = Math[delta >= 1 ? "floor" : "ceil"](delta / lowestDelta), deltaX = Math[deltaX >= 1 ? "floor" : "ceil"](deltaX / lowestDelta), deltaY = Math[deltaY >= 1 ? "floor" : "ceil"](deltaY / lowestDelta), special.settings.normalizeOffset && this.getBoundingClientRect) {
                    var boundingRect = this.getBoundingClientRect();
                    offsetX = event.clientX - boundingRect.left, offsetY = event.clientY - boundingRect.top
                }
                return event.deltaX = deltaX, event.deltaY = deltaY, event.deltaFactor = lowestDelta, event.offsetX = offsetX, event.offsetY = offsetY, event.deltaMode = 0, args.unshift(event, delta, deltaX, deltaY), nullLowestDeltaTimeout && clearTimeout(nullLowestDeltaTimeout), nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200), ($.event.dispatch || $.event.handle).apply(this, args)
            }
        }

        function nullLowestDelta() {
            lowestDelta = null
        }

        function shouldAdjustOldDeltas(orgEvent, absDelta) {
            return special.settings.adjustOldDeltas && "mousewheel" === orgEvent.type && absDelta % 120 === 0
        }
        var nullLowestDeltaTimeout, lowestDelta, toFix = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
            toBind = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],
            slice = Array.prototype.slice;
        if ($.event.fixHooks)
            for (var i = toFix.length; i;) $.event.fixHooks[toFix[--i]] = $.event.mouseHooks;
        var special = $.event.special.mousewheel = {
            version: "3.1.11",
            setup: function () {
                if (this.addEventListener)
                    for (var i = toBind.length; i;) this.addEventListener(toBind[--i], handler, !1);
                else this.onmousewheel = handler;
                $.data(this, "mousewheel-line-height", special.getLineHeight(this)), $.data(this, "mousewheel-page-height", special.getPageHeight(this))
            }, teardown: function () {
                if (this.removeEventListener)
                    for (var i = toBind.length; i;) this.removeEventListener(toBind[--i], handler, !1);
                else this.onmousewheel = null;
                $.removeData(this, "mousewheel-line-height"), $.removeData(this, "mousewheel-page-height")
            }, getLineHeight: function (elem) {
                var $parent = $(elem)["offsetParent" in $.fn ? "offsetParent" : "parent"]();
                return $parent.length || ($parent = $("body")), parseInt($parent.css("fontSize"), 10)
            }, getPageHeight: function (elem) {
                return $(elem).height()
            }, settings: {
                adjustOldDeltas: !0,
                normalizeOffset: !0
            }
        };
        $.fn.extend({
            mousewheel: function (fn) {
                return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel")
            }, unmousewheel: function (fn) {
                return this.unbind("mousewheel", fn)
            }
        })
    }),
    function ($) {
        "use strict";
        var has3d, vendor = "",
            PI = Math.PI,
            A90 = PI / 2,
            isTouch = "ontouchstart" in window,
            events = isTouch ? {
                start: "touchstart",
                move: "touchmove",
                end: "touchend"
            } : {
                start: "mousedown",
                move: "mousemove",
                end: "mouseup"
            },
            corners = {
                backward: ["bl", "tl"],
                forward: ["br", "tr"],
                all: ["tl", "bl", "tr", "br"]
            },
            displays = ["single", "double"],
            turnOptions = {
                page: 1,
                gradients: !0,
                duration: 600,
                acceleration: !0,
                display: "double",
                when: null
            },
            flipOptions = {
                folding: null,
                corners: "forward",
                cornerSize: 100,
                gradients: !0,
                duration: 600,
                acceleration: !0
            },
            pagesInDOM = 6,
            pagePosition = {
                0: {
                    top: 0,
                    left: 0,
                    right: "auto",
                    bottom: "auto"
                },
                1: {
                    top: 0,
                    right: 0,
                    left: "auto",
                    bottom: "auto"
                }
            },
            divAtt = function (top, left, zIndex, overf) {
                return {
                    css: {
                        position: "absolute",
                        top: top,
                        left: left,
                        overflow: overf || "hidden",
                        "z-index": zIndex || "auto"
                    }
                }
            },
            bezier = function (p1, p2, p3, p4, t) {
                var mum1 = 1 - t,
                    mum13 = mum1 * mum1 * mum1,
                    mu3 = t * t * t;
                return point2D(Math.round(mum13 * p1.x + 3 * t * mum1 * mum1 * p2.x + 3 * t * t * mum1 * p3.x + mu3 * p4.x), Math.round(mum13 * p1.y + 3 * t * mum1 * mum1 * p2.y + 3 * t * t * mum1 * p3.y + mu3 * p4.y))
            },
            deg = function (radians) {
                return radians / PI * 180
            },
            point2D = function (x, y) {
                return {
                    x: x,
                    y: y
                }
            },
            translate = function (x, y, use3d) {
                return has3d && use3d ? " translate3d(" + x + "px," + y + "px, 0px) " : " translate(" + x + "px, " + y + "px) "
            },
            rotate = function (degrees) {
                return " rotate(" + degrees + "deg) "
            },
            has = function (property, object) {
                return Object.prototype.hasOwnProperty.call(object, property)
            },
            getPrefix = function () {
                for (var vendorPrefixes = ["Moz", "Webkit", "Khtml", "O", "ms"], len = vendorPrefixes.length, vendor = ""; len--;) vendorPrefixes[len] + "Transform" in document.body.style && (vendor = "-" + vendorPrefixes[len].toLowerCase() + "-");
                return vendor
            },
            gradient = function (obj, p0, p1, colors, numColors) {
                var j, cols = [];
                if ("-webkit-" == vendor) {
                    for (j = 0; numColors > j; j++) cols.push("color-stop(" + colors[j][0] + ", " + colors[j][1] + ")");
                    obj.css({
                        "background-image": "-webkit-gradient(linear, " + p0.x + "% " + p0.y + "%,  " + p1.x + "% " + p1.y + "%, " + cols.join(",") + " )"
                    })
                } else {
                    p0 = {
                        x: p0.x / 100 * obj.width(),
                        y: p0.y / 100 * obj.height()
                    }, p1 = {
                        x: p1.x / 100 * obj.width(),
                        y: p1.y / 100 * obj.height()
                    };
                    var dx = p1.x - p0.x,
                        dy = p1.y - p0.y,
                        angle = Math.atan2(dy, dx),
                        angle2 = angle - Math.PI / 2,
                        diagonal = Math.abs(obj.width() * Math.sin(angle2)) + Math.abs(obj.height() * Math.cos(angle2)),
                        gradientDiagonal = Math.sqrt(dy * dy + dx * dx),
                        corner = point2D(p1.x < p0.x ? obj.width() : 0, p1.y < p0.y ? obj.height() : 0),
                        slope = Math.tan(angle),
                        inverse = -1 / slope,
                        x = (inverse * corner.x - corner.y - slope * p0.x + p0.y) / (inverse - slope),
                        c = {
                            x: x,
                            y: inverse * x - inverse * corner.x + corner.y
                        },
                        segA = Math.sqrt(Math.pow(c.x - p0.x, 2) + Math.pow(c.y - p0.y, 2));
                    for (j = 0; numColors > j; j++) cols.push(" " + colors[j][1] + " " + 100 * (segA + gradientDiagonal * colors[j][0]) / diagonal + "%");
                    obj.css({
                        "background-image": vendor + "linear-gradient(" + -angle + "rad," + cols.join(",") + ")"
                    })
                }
            },

            flipMethods = {
                init: function (opts) {
                    return opts.gradients && (opts.frontGradient = !0, opts.backGradient = !0), this.data({
                        f: {}
                    }), this.flip("options", opts), flipMethods._addPageWrapper.call(this), this
                }, setData: function (d) {
                    var data = this.data();
                    return data.f = $.extend(data.f, d), this
                }, options: function (opts) {
                    var data = this.data().f;
                    return opts ? (flipMethods.setData.call(this, {
                        opts: $.extend({}, data.opts || flipOptions, opts)
                    }), this) : data.opts
                }, z: function (z) {
                    var data = this.data().f;
                    return data.opts["z-index"] = z, data.fwrapper.css({
                        "z-index": z || parseInt(data.parent.css("z-index"), 10) || 0
                    }), this
                }, _cAllowed: function () {
                    return corners[this.data().f.opts.corners] || this.data().f.opts.corners
                }, _cornerActivated: function (e) {
                    if (void 0 === e.originalEvent) return !1;
                    e = isTouch ? e.originalEvent.touches : [e];
                    var data = this.data().f,
                        pos = data.parent.offset(),
                        width = this.width(),
                        height = this.height(),
                        c = {
                            x: Math.max(0, e[0].pageX - pos.left),
                            y: Math.max(0, e[0].pageY - pos.top)
                        },
                        csz = data.opts.cornerSize,
                        allowedCorners = flipMethods._cAllowed.call(this);
                    if (c.x <= 0 || c.y <= 0 || c.x >= width || c.y >= height) return !1;
                    if (c.y < csz) c.corner = "t";
                    else {
                        if (!(c.y >= height - csz)) return !1;
                        c.corner = "b"
                    } if (c.x <= csz) c.corner += "l";
                    else {
                        if (!(c.x >= width - csz)) return !1;
                        c.corner += "r"
                    }
                    return -1 == $.inArray(c.corner, allowedCorners) ? !1 : c
                }, _c: function (corner, opts) {
                    return opts = opts || 0, {
                        tl: point2D(opts, opts),
                        tr: point2D(this.width() - opts, opts),
                        bl: point2D(opts, this.height() - opts),
                        br: point2D(this.width() - opts, this.height() - opts)
                    }[corner]
                }, _c2: function (corner) {
                    return {
                        tl: point2D(2 * this.width(), 0),
                        tr: point2D(-this.width(), 0),
                        bl: point2D(2 * this.width(), this.height()),
                        br: point2D(-this.width(), this.height())
                    }[corner]
                }, _foldingPage: function () {
                    var opts = this.data().f.opts;
                    if (opts.folding) return opts.folding;
                    if (opts.turn) {
                        var data = opts.turn.data();
                        return "single" == data.display ? data.pageObjs[opts.next] ? data.pageObjs[0] : null : data.pageObjs[opts.next]
                    }
                }, _backGradient: function () {
                    var data = this.data().f,
                        turn = data.opts.turn,
                        gradient = data.opts.backGradient && (!turn || "single" == turn.data().display || 2 != data.opts.page && data.opts.page != turn.data().totalPages - 1);
                    return gradient && !data.bshadow && (data.bshadow = $("<div/>", divAtt(0, 0, 1)).css({
                        position: "",
                        width: this.width(),
                        height: this.height()
                    }).appendTo(data.parent)), gradient
                }, resize: function (full) {
                    var data = this.data().f,
                        width = this.width(),
                        height = this.height(),
                        size = Math.round(Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)));
                    full && (data.wrapper.css({
                        width: size,
                        height: size
                    }), data.fwrapper.css({
                        width: size,
                        height: size
                    }).children(":first-child").css({
                        width: width,
                        height: height
                    }), data.fpage.css({
                        width: height,
                        height: width
                    }), data.opts.frontGradient && data.ashadow.css({
                        width: height,
                        height: width
                    }), flipMethods._backGradient.call(this) && data.bshadow.css({
                        width: width,
                        height: height
                    })), data.parent.is(":visible") && (data.fwrapper.css({
                        top: data.parent.offset().top,
                        left: data.parent.offset().left
                    }), data.opts.turn && data.fparent.css({
                        top: -data.opts.turn.offset().top,
                        left: -data.opts.turn.offset().left
                    })), this.flip("z", data.opts["z-index"])
                }, _addPageWrapper: function () {
                    var data = this.data().f,
                        parent = this.parent();
                    if (!data.wrapper) {
                        {
                            var width = (this.css("left"), this.css("top"), this.width()),
                                height = this.height();
                            Math.round(Math.sqrt(Math.pow(width, 2) + Math.pow(height, 2)))
                        }
                        if (data.parent = parent, data.fparent = data.opts.turn ? data.opts.turn.data().fparent : $("#turn-fwrappers"), !data.fparent) {
                            var fparent = $("<div/>", {
                                css: {
                                    "pointer-events": "none"
                                }
                            }).hide();
                            fparent.data().flips = 0, data.opts.turn ? (fparent.css(divAtt(-data.opts.turn.offset().top, -data.opts.turn.offset().left, "auto", "visible").css).appendTo(data.opts.turn), data.opts.turn.data().fparent = fparent) : fparent.css(divAtt(0, 0, "auto", "visible").css).attr("id", "turn-fwrappers").appendTo($("body")), data.fparent = fparent
                        }
                        this.css({
                            position: "absolute",
                            top: 0,
                            left: 0,
                            bottom: "auto",
                            right: "auto"
                        }), data.wrapper = $("<div/>", divAtt(0, 0, this.css("z-index"))).appendTo(parent).prepend(this), data.fwrapper = $("<div/>", divAtt(parent.offset().top, parent.offset().left)).hide().appendTo(data.fparent), data.fpage = $("<div/>", {
                            css: {
                                cursor: "default"
                            }
                        }).appendTo($("<div/>", divAtt(0, 0, 0, "visible")).appendTo(data.fwrapper)), data.opts.frontGradient && (data.ashadow = $("<div/>", divAtt(0, 0, 1)).appendTo(data.fpage)), flipMethods.setData.call(this, data), flipMethods.resize.call(this, !0)
                    }
                }, _fold: function (point) {
                    var px, gradientEndPointA, gradientEndPointB, gradientStartV, gradientSize, gradientOpacity, that = this,
                        a = 0,
                        alpha = 0,
                        mv = point2D(0, 0),
                        df = point2D(0, 0),
                        tr = point2D(0, 0),
                        width = this.width(),
                        height = this.height(),
                        folding = flipMethods._foldingPage.call(this),
                        data = (Math.tan(alpha), this.data().f),
                        ac = data.opts.acceleration,
                        h = data.wrapper.height(),
                        o = flipMethods._c.call(this, point.corner),
                        top = "t" == point.corner.substr(0, 1),
                        left = "l" == point.corner.substr(1, 1),
                        compute = function () {
                            var middle, rel = point2D(o.x ? o.x - point.x : point.x, o.y ? o.y - point.y : point.y),
                                tan = Math.atan2(rel.y, rel.x);
                            alpha = A90 - tan, a = deg(alpha), middle = point2D(left ? width - rel.x / 2 : point.x + rel.x / 2, rel.y / 2);
                            var gamma = alpha - Math.atan2(middle.y, middle.x),
                                distance = Math.max(0, Math.sin(gamma) * Math.sqrt(Math.pow(middle.x, 2) + Math.pow(middle.y, 2)));
                            if (tr = point2D(distance * Math.sin(alpha), distance * Math.cos(alpha)), alpha > A90 && (tr.x = tr.x + Math.abs(tr.y * Math.tan(tan)), tr.y = 0, Math.round(tr.x * Math.tan(PI - alpha)) < height)) return point.y = Math.sqrt(Math.pow(height, 2) + 2 * middle.x * rel.x), top && (point.y = height - point.y), compute();
                            if (alpha > A90) {
                                var beta = PI - alpha,
                                    dd = h - height / Math.sin(beta);
                                mv = point2D(Math.round(dd * Math.cos(beta)), Math.round(dd * Math.sin(beta))), left && (mv.x = -mv.x), top && (mv.y = -mv.y)
                            }
                            px = Math.round(tr.y / Math.tan(alpha) + tr.x);
                            var side = width - px,
                                sideX = side * Math.cos(2 * alpha),
                                sideY = side * Math.sin(2 * alpha);
                            df = point2D(Math.round(left ? side - sideX : px + sideX), Math.round(top ? sideY : height - sideY)), gradientSize = side * Math.sin(alpha);
                            var endingPoint = flipMethods._c2.call(that, point.corner),
                                far = Math.sqrt(Math.pow(endingPoint.x - point.x, 2) + Math.pow(endingPoint.y - point.y, 2));
                            return gradientOpacity = width > far ? far / width : 1, data.opts.frontGradient && (gradientStartV = gradientSize > 100 ? (gradientSize - 100) / gradientSize : 0, gradientEndPointA = point2D(gradientSize * Math.sin(A90 - alpha) / height * 100, gradientSize * Math.cos(A90 - alpha) / width * 100), top && (gradientEndPointA.y = 100 - gradientEndPointA.y), left && (gradientEndPointA.x = 100 - gradientEndPointA.x)), flipMethods._backGradient.call(that) && (gradientEndPointB = point2D(gradientSize * Math.sin(alpha) / width * 100, gradientSize * Math.cos(alpha) / height * 100), left || (gradientEndPointB.x = 100 - gradientEndPointB.x), top || (gradientEndPointB.y = 100 - gradientEndPointB.y)), tr.x = Math.round(tr.x), tr.y = Math.round(tr.y), !0
                        },
                        transform = function (tr, c, x, a) {
                            var f = ["0", "auto"],
                                mvW = (width - h) * x[0] / 100,
                                mvH = (height - h) * x[1] / 100,
                                v = {
                                    left: f[c[0]],
                                    top: f[c[1]],
                                    right: f[c[2]],
                                    bottom: f[c[3]]
                                },
                                aliasingFk = 90 != a && -90 != a ? left ? -1 : 1 : 0;
                            x = x[0] + "% " + x[1] + "%", that.css(v).transform(rotate(a) + translate(tr.x + aliasingFk, tr.y, ac), x), data.fpage.parent().css(v), data.wrapper.transform(translate(-tr.x + mvW - aliasingFk, -tr.y + mvH, ac) + rotate(-a), x), data.fwrapper.transform(translate(-tr.x + mv.x + mvW, -tr.y + mv.y + mvH, ac) + rotate(-a), x), data.fpage.parent().transform(rotate(a) + translate(tr.x + df.x - mv.x, tr.y + df.y - mv.y, ac), x), data.opts.frontGradient && gradient(data.ashadow, point2D(left ? 100 : 0, top ? 100 : 0), point2D(gradientEndPointA.x, gradientEndPointA.y), [
                                [gradientStartV, "rgba(0,0,0,0)"],
                                [.8 * (1 - gradientStartV) + gradientStartV, "rgba(0,0,0," + .2 * gradientOpacity + ")"],
                                [1, "rgba(255,255,255," + .2 * gradientOpacity + ")"]
                            ], 3, alpha), flipMethods._backGradient.call(that) && gradient(data.bshadow, point2D(left ? 0 : 100, top ? 0 : 100), point2D(gradientEndPointB.x, gradientEndPointB.y), [
                                [.8, "rgba(0,0,0,0)"],
                                [1, "rgba(0,0,0," + .3 * gradientOpacity + ")"],
                                [1, "rgba(0,0,0,0)"]
                            ], 3)
                        };
                    switch (point.corner) {
                    case "tl":
                        point.x = Math.max(point.x, 1), compute(), transform(tr, [1, 0, 0, 1], [100, 0], a), data.fpage.transform(translate(-height, -width, ac) + rotate(90 - 2 * a), "100% 100%"), folding.transform(rotate(90) + translate(0, -height, ac), "0% 0%");
                        break;
                    case "tr":
                        point.x = Math.min(point.x, width - 1), compute(), transform(point2D(-tr.x, tr.y), [0, 0, 0, 1], [0, 0], -a), data.fpage.transform(translate(0, -width, ac) + rotate(-90 + 2 * a), "0% 100%"), folding.transform(rotate(270) + translate(-width, 0, ac), "0% 0%");
                        break;
                    case "bl":
                        point.x = Math.max(point.x, 1), compute(), transform(point2D(tr.x, -tr.y), [1, 1, 0, 0], [100, 100], -a), data.fpage.transform(translate(-height, 0, ac) + rotate(-90 + 2 * a), "100% 0%"), folding.transform(rotate(270) + translate(-width, 0, ac), "0% 0%");
                        break;
                    case "br":
                        point.x = Math.min(point.x, width - 1), compute(), transform(point2D(-tr.x, -tr.y), [0, 1, 1, 0], [0, 100], a), data.fpage.transform(rotate(90 - 2 * a), "0% 0%"), folding.transform(rotate(90) + translate(0, -height, ac), "0% 0%")
                    }
                    data.point = point
                }, _moveFoldingPage: function (bool) {
                    var data = this.data().f,
                        folding = flipMethods._foldingPage.call(this);
                    folding && (bool ? data.fpage.children()[data.ashadow ? "1" : "0"] || (flipMethods.setData.call(this, {
                        backParent: folding.parent()
                    }), data.fpage.prepend(folding)) : data.backParent && data.backParent.prepend(folding))
                }, _showFoldedPage: function (c, animate) {
                    var folding = flipMethods._foldingPage.call(this),
                        dd = this.data(),
                        data = dd.f;
                    if (!data.point || data.point.corner != c.corner) {
                        var event = $.Event("start");
                        if (this.trigger(event, [data.opts, c.corner]), event.isDefaultPrevented()) return !1
                    }
                    if (folding) {
                        if (animate) {
                            var that = this,
                                point = data.point && data.point.corner == c.corner ? data.point : flipMethods._c.call(this, c.corner, 1);
                            this.animatef({
                                from: [point.x, point.y],
                                to: [c.x, c.y],
                                duration: 500,
                                frame: function (v) {
                                    c.x = Math.round(v[0]), c.y = Math.round(v[1]), flipMethods._fold.call(that, c)
                                }
                            })
                        } else flipMethods._fold.call(this, c), dd.effect && !dd.effect.turning && this.animatef(!1);
                        return data.fwrapper.is(":visible") || (data.fparent.show().data().flips++, flipMethods._moveFoldingPage.call(this, !0), data.fwrapper.show(), data.bshadow && data.bshadow.show()), !0
                    }
                    return !1
                }, hide: function () {
                    var data = this.data().f,
                        folding = flipMethods._foldingPage.call(this);
                    return 0 === --data.fparent.data().flips && data.fparent.hide(), this.css({
                        left: 0,
                        top: 0,
                        right: "auto",
                        bottom: "auto"
                    }).transform("", "0% 100%"), data.wrapper.transform("", "0% 100%"), data.fwrapper.hide(), data.bshadow && data.bshadow.hide(), folding.transform("", "0% 0%"), this
                }, hideFoldedPage: function (animate) {
                    var data = this.data().f;
                    if (data.point) {
                        var that = this,
                            p1 = data.point,
                            hide = function () {
                                data.point = null, that.flip("hide"), that.trigger("end", [!1])
                            };
                        if (animate) {
                            var p4 = flipMethods._c.call(this, p1.corner),
                                top = "t" == p1.corner.substr(0, 1),
                                delta = top ? Math.min(0, p1.y - p4.y) / 2 : Math.max(0, p1.y - p4.y) / 2,
                                p2 = point2D(p1.x, p1.y + delta),
                                p3 = point2D(p4.x, p4.y - delta);
                            this.animatef({
                                from: 0,
                                to: 1,
                                frame: function (v) {
                                    var np = bezier(p1, p2, p3, p4, v);
                                    p1.x = np.x, p1.y = np.y, flipMethods._fold.call(that, p1)
                                }, complete: hide,
                                duration: 800,
                                hiding: !0
                            })
                        } else this.animatef(!1), hide()
                    }
                }, turnPage: function (corner) {
                    var that = this,
                        data = this.data().f;
                    corner = {
                        corner: data.corner ? data.corner.corner : corner || flipMethods._cAllowed.call(this)[0]
                    };
                    var p1 = data.point || flipMethods._c.call(this, corner.corner, data.opts.turn ? data.opts.turn.data().opts.elevation : 0),
                        p4 = flipMethods._c2.call(this, corner.corner);
                    this.trigger("flip").animatef({
                        from: 0,
                        to: 1,
                        frame: function (v) {
                            var np = bezier(p1, p1, p4, p4, v);
                            corner.x = np.x, corner.y = np.y, flipMethods._showFoldedPage.call(that, corner)
                        }, complete: function () {
                            that.trigger("end", [!0])
                        }, duration: data.opts.duration,
                        turning: !0
                    }), data.corner = null
                }, moving: function () {
                    return "effect" in this.data()
                }, isTurning: function () {
                    return this.flip("moving") && this.data().effect.turning
                }, _eventStart: function (e) {
                    var data = this.data().f;
                    if (!data.disabled && !this.flip("isTurning")) {
                        if (data.corner = flipMethods._cornerActivated.call(this, e), data.corner && flipMethods._foldingPage.call(this, data.corner)) return flipMethods._moveFoldingPage.call(this, !0), this.trigger("pressed", [data.point]), !1;
                        data.corner = null
                    }
                }, _eventMove: function (e) {
                    var data = this.data().f;
                    if (!data.disabled)
                        if (e = isTouch ? e.originalEvent.touches : [e], data.corner) {
                            var pos = data.parent.offset();
                            data.corner.x = e[0].pageX - pos.left, data.corner.y = e[0].pageY - pos.top, flipMethods._showFoldedPage.call(this, data.corner)
                        } else if (!this.data().effect && this.is(":visible")) {
                        var corner = flipMethods._cornerActivated.call(this, e[0]);
                        if (corner) {
                            var origin = flipMethods._c.call(this, corner.corner, data.opts.cornerSize / 2);
                            corner.x = origin.x, corner.y = origin.y, flipMethods._showFoldedPage.call(this, corner, !0)
                        } else flipMethods.hideFoldedPage.call(this, !0)
                    }
                }, _eventEnd: function () {
                    var data = this.data().f;
                    if (!data.disabled && data.point) {
                        var event = $.Event("released");
                        this.trigger(event, [data.point]), event.isDefaultPrevented() || flipMethods.hideFoldedPage.call(this, !0)
                    }
                    data.corner = null
                }, disable: function (disable) {
                    return flipMethods.setData.call(this, {
                        disabled: disable
                    }), this
                }
            },
            cla = function (that, methods, args) {
                if (args[0] && "object" != typeof args[0]) {
                    if (methods[args[0]] && "_" != args[0].toString().substr(0, 1)) return methods[args[0]].apply(that, Array.prototype.slice.call(args, 1));
                    throw args[0] + " is an invalid value"
                }
                return methods.init.apply(that, args)
            };
        $.extend($.fn, {
            flip: function () {
                return cla(this, flipMethods, arguments)
            }, transform: function (transform, origin) {
                var properties = {};
                return origin && (properties[vendor + "transform-origin"] = origin), properties[vendor + "transform"] = transform, this.css(properties)
            }, animatef: function (point) {
                var data = this.data();
                if (data.effect && clearInterval(data.effect.handle), point) {
                    point.to.length || (point.to = [point.to]), point.from.length || (point.from = [point.from]), point.easing || (point.easing = function (x, t, b, c, data) {
                        return c * Math.sqrt(1 - (t = t / data - 1) * t) + b
                    });
                    var j, diff = [],
                        len = point.to.length,
                        that = this,
                        fps = point.fps || 30,
                        time = -fps,
                        f = function () {
                            var j, v = [];
                            for (time = Math.min(point.duration, time + fps), j = 0; len > j; j++) v.push(point.easing(1, time, point.from[j], diff[j], point.duration));
                            point.frame(1 == len ? v[0] : v), time == point.duration && (clearInterval(data.effect.handle), delete data.effect, that.data(data), point.complete && point.complete())
                        };
                    for (j = 0; len > j; j++) diff.push(point.to[j] - point.from[j]);
                    data.effect = point, data.effect.handle = setInterval(f, fps), this.data(data), f()
                } else delete data.effect
            }
        }), $.isTouch = isTouch
    }(jQuery),
    function (window, jq) {
        function checkSize() {
            winWidth = jq(window).width(), winHeight = jq(window).height(), calcByWidth = 1900 / 1084 > winWidth / winHeight, 601 > winHeight && (jq("body").addClass("m"), noAnimate = !0)
        }

        function onResize() {
            checkSize(), 1366 > winWidth ? jq("#a .info-wrap").addClass("info-wrap-sort") : jq("#a .info-wrap").removeClass("info-wrap-sort"), 1e3 > winWidth ? jq("body").width(1e3) : jq("body").css("width", "100%");
            var screenHeight = winHeight /*-getTopHeight()-getFooterHeight()*/ ;
            return jq(".screen").height(screenHeight), scrollSize = screenHeight, jq("#fullPage").height(winHeight /*-getTopHeight()*/ ), jq("#scroller").css("top", curIndex * screenHeight * -1), is_mobi && window.location.search.indexOf("mv=fp") < 0 ? void jq("head").append("<link rel='stylesheet' type='text/css' href='css/ie-fixed.css' />") : (resizeA(screenHeight), void resizeObj(screenHeight))
        }

        function resizeA(screenHeight) {
            jq(".ani-wrap").height(screenHeight - jq(".info-wrap").height())
        }

        function resizeObj(screenHeight) {
            for (var _h, w, h, o, objList = jq(".obj"), i = 0; o = objList[i]; i += 1) {
                o = jq(o);
                var ow = o.data("w") || o.attr("width"),
                    oh = o.data("h") || o.attr("height");
                if (!isNaN(ow) && !isNaN(oh) && (calcByWidth ? (h = winWidth * oh / ow * (ow / 1900), w = h * ow / oh) : (_h = screenHeight * (oh / 1060), w = _h * ow / oh, h = w * oh / ow), o.width(w).height(h), "iPad" === o.attr("id"))) {
                    var book = jq("#booksTurn");
                    book.css({
                        width: "100%",
                        height: "100%"
                    });
                    try {
                        book.turn("size", book.width(), book.height())
                    } catch (e) {}
                }
            }
        }

        function onLoad() {
            sideNavFunc(), scrollArrowFun(), onResize()
        }

        function sideNavFunc() {
            jq(".side-nav-item").each(function () {
                var $sideNav = jq("#sideNav"),
                    _self = jq(this),
                    index = jq(this).index();
                _self.bind("click", function () {
                    scrollTo(index), $sideNav.removeClass("side-nav-0 side-nav-1 side-nav-2 side-nav-3 side-nav-4 side-nav-5 side-nav-6"), $sideNav.addClass("side-nav-" + index), jq("#sideNav .side-nav-item").removeClass("side-nav-item-cur")
                })
            })
        }

        function scrollArrowFun() {
            var $arrowDow = jq(".arrow-down"),
                $arrowUp = jq(".arrow-up");
            $arrowDow.bind("click", function () {
                scrollTo(curIndex + 1)
            }), $arrowUp.bind("click", function () {
                scrollTo(curIndex - 1)
            })
        }

        function onMouseMove(ev) {
            if (!noAnimate) {
                var left = (ev.clientX - .6 * winWidth) / (.6 * winWidth),
                    top = (ev.clientY - .6 * winHeight) / (.6 * winWidth),
                    elements = jq(".layer");
                elements.each(function () {
                    var el = jq(this),
                        rate = parseInt(el.data("z")),
                        max = 4 * (11 - rate),
                        toLeft = left * max,
                        toTop = top * max;
                    el.css("transform", "translate(" + toLeft + "px, " + toTop + "px)")
                })
            }
        }

        function onScroll(ev) {
            var newTimer = Date.parse(new Date),
                direction = ev.deltaY < 0 ? -1 : 1;
            if (1e3 > newTimer - lastScrollTimer) return !1;
            if (direction > 0 && 0 === curIndex) return !1;
            if (0 > direction && 6 === curIndex) return !1;
            lastScrollTimer = newTimer;
            var toScreen = curIndex - direction;
            return scrollTo(toScreen)
        }

        function scrollTo(targetIndex) {
            if (!(0 > targetIndex && targetIndex > 6)) {
                var distance = targetIndex * scrollSize * -1,
                    direction = targetIndex - curIndex > 0 ? -1 : 1;
                onBeforeScroll(direction), jq("#scroller").animate({
                    top: distance + "px"
                }, 900, "easeInOutSine", function () {
                    curIndex = targetIndex, onAfterScroll(direction)
                })
            }
        }

        function onBeforeScroll() {
            0 === curIndex && jq(".info-wrap").hide(), (0 === curIndex || 6 === curIndex) && jq("#footer").hide(), 2 === curIndex , jq(".arrow-down, .arrow-up").hide()
        }

        function onAfterScroll() {
            var curr = parseInt(curIndex),
                $sideNav = jq("#sideNav"),
                $sideNavitem = jq("#sideNav .side-nav-item");
            $sideNavitem.removeClass("side-nav-item-cur"), $sideNav.removeClass("side-nav-0 side-nav-1 side-nav-2 side-nav-3 side-nav-4 side-nav-5 side-nav-6"), $sideNavitem.eq(curr).addClass("side-nav-item-cur"), $sideNav.addClass("side-nav-" + curr), 0 === curIndex ? (jq(".info-wrap").fadeIn(), jq("#fullPage").addClass("show-a")) : jq("#fullPage").removeClass("show-a"), (6 === curIndex || 0 === curIndex) && jq("#footer").fadeIn(), 
            3 === curIndex && (setTimeout(function () {
                jq("#renwu span").eq(0).addClass("fadeIn")
            }, 200), setTimeout(function () {
                jq("#renwu span").eq(1).addClass("fadeIn")
            }, 800), setTimeout(function () {
                jq("#renwu span").eq(2).addClass("fadeIn")
            }, 1600), setTimeout(function () {
                jq("#renwu span").eq(3).addClass("fadeIn")
            }, 2e3)), 6 > curIndex && jq(".arrow-down").show(), 0 !== curIndex && jq(".arrow-up").show()
        }

        function getFooterHeight() {
            return jq("#footer").height()
        }

        function getTopHeight() {
            return jq("#header").height()
        }
        var is_mobi = (null != navigator.userAgent.match(/(iPad|iPod|iPhone)/i), null != navigator.userAgent.toLowerCase().match(/(ipod|iphone|android|coolpad|mmp|smartphone|midp|wap|xoom|symbian|j2me|blackberry|win ce)/i)),
            lastScrollTimer = 0,
            winWidth = 0,
            winHeight = 0,
            calcByWidth = !0,
            curIndex = 0,
            scrollSize = 0,
            noAnimate = !1;
        jq(function (jq) {
            jq(window).bind({
                load: onLoad,
                resize: onResize
            }), jq("html").hasClass("pages-html") || (jq(document).bind({
                mousewheel: onScroll
            }), jq("#fullPage").bind({
                mousemove: onMouseMove
            }), jq(".col").bind({
                mouseover: function () {
                    jq(this).addClass("hover")
                }, mouseout: function () {
                    jq(this).removeClass("hover")
                }
            }))
        }(jq))
    }(window, jQuery);